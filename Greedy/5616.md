## 5616.数组的最小偏移量

给你一个由 n 个正整数组成的数组 nums 。

你可以对数组的任意元素执行任意次数的两类操作：

如果元素是 偶数 ，除以 2
例如，如果数组是 [1,2,3,4] ，那么你可以对最后一个元素执行此操作，使其变成 [1,2,3,2]
如果元素是 奇数 ，乘上 2
例如，如果数组是 [1,2,3,4] ，那么你可以对第一个元素执行此操作，使其变成 [2,2,3,4]
数组的 偏移量 是数组中任意两个元素之间的 最大差值 。

返回数组在执行某些操作之后可以拥有的 最小偏移量 。

 

示例 1：
```
输入：nums = [1,2,3,4]
输出：1
解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1
```
示例 2：
```
输入：nums = [4,1,5,20,3]
输出：3
解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3
```
示例 3：
```
输入：nums = [2,10,8]
输出：3
```

#### 思路

这题首先要考虑到一个规律，比如一个奇数3，它能变成什么数字->3->6 奇数只能乘2后除回来，但是偶数的话可以一直除。所以一个简单的想法就是把所有的数字都变成偶数，统一的进行操作。

都变成偶数之后就是看最大的和最小的差值，每次把最大的除以二，和最小的做减法。那这里面就要用到优先队列去维护找到每次的最大值

```c++
class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
        int n=nums.size(),mi=INT_MAX,res=INT_MAX;
        priority_queue<int> q;
        for(int i=0;i<n;i++){
            if(nums[i]%2==1){
                nums[i] *= 2;
            }
            q.push(nums[i]);
            mi=min(mi,nums[i]);
        }
        while(1){
            int d=q.top();

            q.pop();
            res = min(res, d-mi);
            if(d%2==1)  break;
            mi=min(d/2,mi);
            q.push(d/2);
        }
        return res;
    }
};
```

